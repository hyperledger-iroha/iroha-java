package jp.co.soramitsu.schema.codegen

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import jp.co.soramitsu.schema.StringType
import jp.co.soramitsu.schema.TypePreset
import jp.co.soramitsu.schema.definitions.types.Type
import jp.co.soramitsu.schema.definitions.types.composite.*
import jp.co.soramitsu.schema.definitions.types.primitives.*
import java.nio.file.Paths
import java.util.*


object CodeGenerator {

    fun generate(typePreset: TypePreset) {
        typePreset.map { (_, typeRef) ->
            when (val type = typeRef.value) {
                is Struct -> generateRegularStruct(type)
                is EnumType -> generateEnum(type)
                is TupleStruct -> generateTupleStruct(type)
                else -> null
            }
        }
            .filterNotNull()
            .map { it.addComment("Do not change. Autogenerated code") }
            .map(FileSpec.Builder::build)
            .forEach { it.writeTo(Paths.get("datamodel-generated/src/main/kotlin")) }
    }

    private fun generateClassSkeleton(type: Type<*>, className: String): TypeSpec.Builder {
        val clazz = TypeSpec.classBuilder(className)
            .addType(createCompanion(type).build())
            .addModifiers(KModifier.PUBLIC)

        return clazz
    }

    private fun generateRegularStruct(type: Struct): FileSpec.Builder? {
        val (className, packageName, _) = defineFullClassNames(type.name)

        val clazz = generateClassSkeleton(type, className)
            .addKdoc("$className\n\n")
            .addKdoc("Matched to regular structure in Rust")

        val constructorBuilder = FunSpec.constructorBuilder()

        for ((name, typeRef) in type.mapping) {
            val normalizedName = convertToCamelCase(name)
            val kotlinType = resolveKotlinType(typeRef.value!!)

            constructorBuilder.addParameter(
                ParameterSpec.builder(normalizedName, kotlinType)
                    .build()
            )

            clazz.addProperty(
                PropertySpec.builder(normalizedName, kotlinType, KModifier.PRIVATE)
                    .initializer(normalizedName)
                    .build()
            )
        }

        if (constructorBuilder.parameters.isNotEmpty()) {
            clazz.primaryConstructor(constructorBuilder.build())
        }

        return FileSpec.builder("jp.co.soramitsu.iroha2.generated.$packageName", className)
            .addType(clazz.build())
    }

    private fun generateTupleStruct(type: TupleStruct): FileSpec.Builder? {
        val (className, packageName, _) = defineFullClassNames(type.name)

        val clazz = generateClassSkeleton(type, className)
            .addKdoc("$className\n\n")
            .addKdoc("Matched to tuple structure in Rust")

        val constructorBuilder = FunSpec.constructorBuilder()

        for (typeRef in type.types) {
            val normalizedName = when (typeRef.value!!) {
                is FixedByteArray -> {
                    "array"
                }
                else -> {
                    val (propertyName, _) = defineFullClassNames(typeRef.value!!.name)
                    propertyName.decapitalize(Locale.getDefault())
                }
            }
            val kotlinType = resolveKotlinType(typeRef.value!!)

            constructorBuilder.addParameter(
                ParameterSpec.builder(normalizedName, kotlinType)
                    .build()
            )

            clazz.addProperty(
                PropertySpec.builder(normalizedName, kotlinType, KModifier.PRIVATE)
                    .initializer(normalizedName)
                    .build()
            )
        }

        if (constructorBuilder.parameters.isNotEmpty()) {
            clazz.primaryConstructor(constructorBuilder.build())
        }

        return FileSpec.builder("jp.co.soramitsu.iroha2.generated.$packageName", className)
            .addType(clazz.build())
    }

    private fun generateEnum(type: EnumType): FileSpec.Builder? {
        val (className, packageName, _) = defineFullClassNames(type.name)

        val clazz = generateClassSkeleton(type, className)
            .addModifiers(KModifier.ABSTRACT)
            .addKdoc("$className\n\n")
            .addKdoc("Matched to enum in Rust")

        for (variant in type.variants) {

            val variantClass = TypeSpec.classBuilder(variant.name)
                .addModifiers(KModifier.PUBLIC)
                .superclass(ClassName("jp.co.soramitsu.iroha2.generated.$packageName", className))
                .addType(
                    TypeSpec.companionObjectBuilder()
                        .addProperty(
                            PropertySpec.builder("DISCRIMINANT", Int::class, KModifier.CONST)
                                .initializer("%L", variant.discriminant)
                                .build()
                        ).build()
                ).addKdoc("'${variant.name}' variant")

            if (variant.type != null) {
                val (variantPropertyName, _, _) = defineFullClassNames(variant.name)
                val normalizedName = convertToCamelCase(variantPropertyName)
                    .decapitalize(Locale.getDefault())
                val kotlinType = resolveKotlinType(variant.type.value!!)
                val constructorBuilder = FunSpec.constructorBuilder()
                    .addParameter(
                        ParameterSpec.builder(normalizedName, kotlinType)
                            .build()
                    )

                variantClass.addProperty(
                    PropertySpec.builder(normalizedName, kotlinType, KModifier.PRIVATE)
                        .initializer(normalizedName)
                        .build()
                )

                variantClass.primaryConstructor(constructorBuilder.build())
            }

            clazz.addType(variantClass.build())
        }

        return FileSpec.builder("jp.co.soramitsu.iroha2.generated.$packageName", className)
            .addType(clazz.build())
    }

    private fun defineFullClassNames(typeFullName: String): Foo {
        //expected only one wildcard at most
        val wildcard = typeFullName.substringAfter('<', "")
            .substringBeforeLast('>', "")
        val className = typeFullName.substringBefore('<')
            .substringAfterLast("::")
        val packageName = typeFullName.substringBeforeLast(className)
            .removeSuffix("::")
            .removePrefix("iroha")
            .replace("::", ".")
            .replace("_", "")
        return Foo(className, packageName, wildcard)
    }

    private data class Foo(val className: String, val packageName: String, val wildcard: String)

    private fun convertToCamelCase(target: String): String {
        val tokenizer = StringTokenizer(target, "_")
        return if (tokenizer.hasMoreTokens()) {
            val resultBuilder = StringBuilder(tokenizer.nextToken())
            for (token in tokenizer) {
                resultBuilder.append((token as String).capitalize(Locale.getDefault()))
            }
            resultBuilder.toString()
        } else {
            target
        }
    }

    private fun resolveKotlinType(type: Type<*>): TypeName {
        return when (type) {
            is StringType -> ClassName("kotlin", "String")
            is BooleanType -> ClassName("kotlin", "Boolean")
            is EnumType, is TupleStruct, is Struct -> {
                val (className, packageName, _) = defineFullClassNames(type.name)
                ClassName("jp.co.soramitsu.iroha2.generated.$packageName", className)
            }
            is Vec -> {
                ClassName("kotlin.collections", "List")
                    .parameterizedBy(resolveKotlinType(type.innerType!!))
            }
            is SetType -> {
                ClassName("kotlin.collections", "Set")
                    .parameterizedBy(resolveKotlinType(type.innerType!!))
            }
            is Option -> {
                ClassName("java.util", "Optional")
                    .parameterizedBy(resolveKotlinType(type.innerType!!))
            }
            is DynamicByteArray -> {
                ClassName("kotlin", "Any")
            }
            is Compact -> ClassName("kotlin", "Int")
            is UIntType -> ClassName("kotlin", "Int")
            is Tuple -> {
                ClassName("kotlin", "Pair")
                    .parameterizedBy(ClassName("kotlin", "String"), ClassName("kotlin", "String"))
            }
            is FixedByteArray -> {
                ClassName("kotlin", "Array")
                    .parameterizedBy(ClassName("kotlin", "Int"))
            }
            else -> throw RuntimeException("unexpected type: $type")
        }
    }

    private fun createCompanion(type: Type<*>): TypeSpec.Builder {
        return TypeSpec.companionObjectBuilder()
            .addProperty(
                PropertySpec.builder("IROHA_FULL_NAME", String::class, KModifier.CONST)
                    .initializer("%S", type.name)
                    .build()
            )
    }
}
